:: # Copyright 2013, Big Switch Networks, Inc.
:: #
:: # LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
:: # the following special exception:
:: #
:: # LOXI Exception
:: #
:: # As a special exception to the terms of the EPL, you may distribute libraries
:: # generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
:: # that copyright and licensing notices generated by LoxiGen are not altered or removed
:: # from the LoxiGen Libraries and the notice provided below is (i) included in
:: # the LoxiGen Libraries, if distributed in source code form and (ii) included in any
:: # documentation for the LoxiGen Libraries, if distributed in binary form.
:: #
:: # Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
:: #
:: # You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
:: # a copy of the EPL at:
:: #
:: # http://www.eclipse.org/legal/epl-v10.html
:: #
:: # Unless required by applicable law or agreed to in writing, software
:: # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
:: # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
:: # EPL for the specific language governing permissions and limitations
:: # under the EPL.
::
:: include('_copyright.c')

/****************************************************************
 *
 * Low level buffer manipulation functions
 * Requires low level type defs
 *
 ****************************************************************/

#ifndef _OF_BUFFER_H_
#define _OF_BUFFER_H_

#include <loci/loci_base.h>
#include <stdio.h>

/* Function type used for a "free" operation of a low level buffer */
typedef void (*of_buffer_free_f)(void *buf);


/****************************************************************
 *
 * Low level buffers accessors handling endian and alignment
 *
 ****************************************************************/

static inline void
buf_ipv6_get(uint8_t *buf, of_ipv6_t *val) {
    MEMCPY(val, buf, sizeof(*val));
    IPV6_NTOH(val, val); /* probably a no-op */
}

static inline void
buf_mac_get(uint8_t *buf, of_mac_addr_t *val) {
    MEMCPY(val, buf, sizeof(*val));
}

static inline void
buf_u64_get(uint8_t *buf, uint64_t *val) {
    MEMCPY(val, buf, sizeof(*val));
    *val = U64_NTOH(*val);
}

static inline void
buf_u32_get(uint8_t *buf, uint32_t *val) {
    MEMCPY(val, buf, sizeof(*val));
    *val = U32_NTOH(*val);
}

static inline void
buf_u16_get(uint8_t *buf, uint16_t *val) {
    MEMCPY(val, buf, sizeof(uint16_t));
    *val = U16_NTOH(*val);
}

static inline void
buf_u8_get(uint8_t *buf, uint8_t *val) {
    *val = *buf;
}

/* Get an unaligned field up to 32 bits */

/*
 * Fill the low order bits of val8 for unaligned access
 *
 * Gets 8 - bit_offset bits (or bits_remaining if less)
 * Bottom refers to the bottom bits of *val8 which come from the
 * top bits of *buf
 */
static inline void
_get_bottom_bits(uint8_t *buf, int bit_offset, int bits_remaining,
                 uint8_t *val8) {
    *val8 = *buf >> bit_offset;
    if (bit_offset + bits_remaining < 8) {
        *val8 &= ((1 << bits_remaining) - 1);
    }
}

/*
 * Fill the high order bits of val8 for unaligned access
 *
 * Top refers to the top bits of *val8 which come from the bottom bits of *buf
 */
static inline void
_get_top_bits(uint8_t *buf, int bit_offset, int bits_remaining,
              uint8_t *val8) {
    /* *val8 has 8 - bit_offset bits already filled, so up to bit_offset bits
     * available in high order bits.  Fill upper bits up to
     * bit width bits from low order bits of *buf.
     */
    *val8 |= (*buf << (8 - bit_offset));
    if (bits_remaining < bit_offset) {
        /* Clear upper bits if not in field */
        *val8 &= ((1 << ((8 - bit_offset) + bits_remaining)) - 1);
    }
}

/**
 * Get an unaligned field up to 32 bits
 */
static inline void
buf_unaligned_get(uint8_t *buf, int bit_offset, int bit_width, uint32_t *val) {
    uint8_t val8;
    int byte_count;

    *val = 0;
    for (byte_count = 0; bit_width > 0; ++byte_count) {
        _get_bottom_bits(&buf[byte_count], bit_offset, bit_width, &val8);
        bit_width -= (8 - bit_offset);
        if (bit_width <= 0) {
            *val |= (((uint32_t)val8) << (byte_count * 8));
            return;
        }
        _get_top_bits(&buf[byte_count + 1], bit_offset, bit_width, &val8);
        *val |= (((uint32_t)val8) << (byte_count * 8));
        bit_width -= bit_offset;
        if (bit_width <= 0) {
            return;
        }
    }
}

/* Indexed by bit_width when < 8 */
static const uint8_t _width_masks[8] = {0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f};

/**
 * Copy from bit 0 in val to bit_offset in *buf, up to bit_width or
 * end of byte (in *buf), whichever is less.
 */

static inline void
_mod_first_byte(uint8_t *buf, int bit_offset, int bit_width, uint32_t val)
{
    uint8_t val8;

    val8 = val & 0xff;
    val8 <<= bit_offset;
    if (bit_offset + bit_width < 8) {
        /* End of field below end of byte */
        /* Clear bits to change in buf */
        *buf &= ~(_width_masks[bit_width] << bit_offset);
        *buf |= val8;
        /* Verify value fits in field */
        ASSERT(!(val8 & ~(_width_masks[bit_width] << bit_offset)));
    } else {
        /* End of field extends at least to end of byte */
        *buf &= 0xff << bit_offset;
        *buf |= val8;
    }
}


/**
 * Copy from bit 0 in val to bit 0 in *buf, up to bit_width or
 * end of byte (in *buf), whichever is less.
 */

static inline void
_mod_byte_from_0(uint8_t *buf, int bit_width, uint32_t val)
{
    uint8_t val8;

    /* Indexed by bit_width when < 8 */

    val8 = val & 0xff;
    if (bit_width < 8) {
        /* Only need bit_width more bits from val */
        *buf &= ~(_width_masks[bit_width]);
        *buf |= val8;
        ASSERT(!(val8 & ~_width_masks[bit_width]));
    } else { /* Goes to end of byte */
        *buf = val & 0xff;
    }
}


/**
 * Set an unaligned field up to 32 bits
 *
 * Put the lower bit_width bits from
 * val into the buffer starting at bit_offset.
 */
static inline void
buf_unaligned_set(uint8_t *buf, int bit_offset, int bit_width, uint32_t val) {
    _mod_first_byte(buf, bit_offset, bit_width, val);
    bit_width -= (8 - bit_offset);
    if (bit_width <= 0) {
        return; /* Done in first byte */
    }
    /* Have used 8-bit_offset bits from val */
    val >>= (8 - bit_offset);

    /* Process up to 8 bits at a time */
    while (bit_width > 0) {
        _mod_byte_from_0(buf, bit_width, val);
        val >>= 8;
        bit_width -= 8;
    }
}

static inline void
buf_octets_get(uint8_t *buf, uint8_t *dst, int bytes) {
    MEMCPY(dst, buf, bytes);
}

static inline void
buf_ipv6_set(uint8_t *buf, of_ipv6_t *val) {
    /* FIXME:  If this is not a NO-OP, need to change the code */
#if 1
    MEMCPY(buf, val, sizeof(*val));
#else
    of_ipv6_t w_val;
    MEMCPY(&w_val, val sizeof(w_val));
    IPV6_HTON(w_val, w_val);
    MEMCPY(buf, &w_val, sizeof(w_val));
#endif
}

static inline void
buf_mac_addr_set(uint8_t *buf, of_mac_addr_t *val) {
    MEMCPY(buf, val, sizeof(of_mac_addr_t));
}

static inline void
buf_u64_set(uint8_t *buf, uint64_t val) {
    val = U64_HTON(val);
    MEMCPY(buf, &val, sizeof(uint64_t));
}

static inline void
buf_u32_set(uint8_t *buf, uint32_t val) {
    val = U32_HTON(val);
    MEMCPY(buf, &val, sizeof(uint32_t));
}

static inline void
buf_u16_set(uint8_t *buf, uint16_t val) {
    val = U16_NTOH(val);
    MEMCPY(buf, &val, sizeof(uint16_t));
}

static inline void
buf_u8_set(uint8_t *buf, uint8_t val) {
    *buf = val;
}

static inline void
buf_octets_set(uint8_t *buf, uint8_t *src, int bytes) {
    MEMCPY(buf, src, bytes);
}


#endif /* _OF_BUFFER_H_ */
